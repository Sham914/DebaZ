import { create } from 'zustand';
import { RoundData } from '../engine/debateGenerator';
import { fetchAiDebate, fetchAiFraming, fetchAiRandomTopic } from '../engine/aiClient';
import { filterTopic } from '../engine/safetyFilter';
import { calculateTotalScores, getWinner } from '../engine/scoringEngine';

export type AppPhase = 'input' | 'framing' | 'debate' | 'victory';

const isPlaceholderHeadline = (headline?: string) => {
  if (!headline || !headline.trim()) return true;
  const normalized = headline.trim().toLowerCase();
  return normalized === 'supporting this position' || normalized === 'opposing this position';
};

const AI_RETRY_OPTIONS = { attempts: 1, delayMs: 1000 };

const STOP_WORDS = new Set([
  'the', 'a', 'an', 'of', 'to', 'and', 'or', 'is', 'are', 'be', 'for', 'in', 'on', 'with', 'as', 'by', 'at', 'from',
]);

const isValidHeadline = (topic: string, headline?: string) => {
  if (!headline || !headline.trim()) return false;
  const words = headline.trim().split(/\s+/);
  if (words.length < 6 || words.length > 18) return false;

  const lowerHeadline = headline.toLowerCase();
  const topicKeywords = topic
    .toLowerCase()
    .split(/\s+/)
    .filter(word => word.length > 3 && !STOP_WORDS.has(word));

  const hasKeyword = topicKeywords.some(word => lowerHeadline.includes(word));
  return hasKeyword;
};

interface DebateState {
  phase: AppPhase;
  topic: string;
  proHeadline: string;
  conHeadline: string;
  rounds: RoundData[];
  currentRoundIndex: number;
  isAnimating: boolean;
  proScore: number;
  conScore: number;
  voteProBonus: number;
  voteConBonus: number;
  winner: 'PRO' | 'CON' | 'TIE' | null;
  shakeScreen: boolean;
  isLoadingAI: boolean;
  aiGenerated: boolean;
  aiError: string | null;

  submitTopic: (raw: string) => Promise<void>;
  randomTopic: () => Promise<void>;
  startDebate: () => Promise<void>;
  advanceRound: () => void;
  setAnimating: (v: boolean) => void;
  voteFor: (side: 'PRO' | 'CON', amount: number) => void;
  triggerShake: () => void;
  reset: () => void;
}

export const useDebateStore = create<DebateState>((set, get) => ({
  phase: 'input',
  topic: '',
  proHeadline: '',
  conHeadline: '',
  rounds: [],
  currentRoundIndex: 0,
  isAnimating: false,
  proScore: 0,
  conScore: 0,
  voteProBonus: 0,
  voteConBonus: 0,
  winner: null,
  shakeScreen: false,
  isLoadingAI: false,
  aiGenerated: false,
  aiError: null,

  submitTopic: async (raw: string) => {
    const trimmed = raw.trim();
    if (!trimmed) return;

    const tryAi = async (topicInput: string) => {
      const safeTopic = filterTopic(topicInput).topic;
      let proHeadline = '';
      let conHeadline = '';

      const framing = await fetchAiFraming(safeTopic, AI_RETRY_OPTIONS);
      proHeadline = framing.proHeadline;
      conHeadline = framing.conHeadline;
      console.info('[AI] Framing generated.');

      if (
        isPlaceholderHeadline(proHeadline)
        || isPlaceholderHeadline(conHeadline)
        || !isValidHeadline(safeTopic, proHeadline)
        || !isValidHeadline(safeTopic, conHeadline)
      ) {
        throw new Error('AI framing failed validation.');
      }

      set({
        topic: safeTopic,
        proHeadline,
        conHeadline,
        rounds: [],
        aiGenerated: true,
        phase: 'framing',
        aiError: null,
      });
    };

    set({ isLoadingAI: true, aiError: null });
    try {
      await tryAi(trimmed);
    } catch (error) {
      console.error('[AI] Framing failed. AI-only mode active.', error);
      set({
        aiGenerated: false,
        aiError: 'AI framing failed. Please try again.',
      });
    } finally {
      set({ isLoadingAI: false });
    }
  },

  randomTopic: async () => {
    set({ isLoadingAI: true, aiError: null });
    let topic = '';

    try {
      topic = await fetchAiRandomTopic();
      console.info('[AI] Random topic generated by AI.');
    } catch {
      console.error('[AI] Random topic failed. AI-only mode active.');
      set({
        aiGenerated: false,
        aiError: 'AI random topic failed. Please try again.',
        isLoadingAI: false,
      });
      return;
    }

    try {
      const safeTopic = filterTopic(topic).topic;
      const framing = await fetchAiFraming(safeTopic, AI_RETRY_OPTIONS);
      const proHeadline = framing.proHeadline;
      const conHeadline = framing.conHeadline;
      console.info('[AI] Framing generated.');

      if (
        isPlaceholderHeadline(proHeadline)
        || isPlaceholderHeadline(conHeadline)
        || !isValidHeadline(safeTopic, proHeadline)
        || !isValidHeadline(safeTopic, conHeadline)
      ) {
        throw new Error('AI framing failed validation.');
      }

      set({
        topic: safeTopic,
        proHeadline,
        conHeadline,
        rounds: [],
        aiGenerated: true,
        phase: 'framing',
        aiError: null,
      });
    } catch (error) {
      console.error('[AI] Framing failed. AI-only mode active.', error);
      set({
        aiGenerated: false,
        aiError: 'AI framing failed. Please try again.',
      });
    } finally {
      set({ isLoadingAI: false });
    }
  },

  startDebate: async () => {
    const { topic } = get();
    if (!topic) return;

    set({ isLoadingAI: true, aiError: null });
    try {
      const ai = await fetchAiDebate(topic, AI_RETRY_OPTIONS);
      set({
        rounds: ai.rounds,
        currentRoundIndex: 0,
        phase: 'debate',
        proScore: 0,
        conScore: 0,
        aiError: null,
      });
      console.info('[AI] Debate generation succeeded.');
    } catch (error) {
      console.error('[AI] Debate generation failed. AI-only mode active.', error);
      set({
        aiGenerated: false,
        aiError: 'AI debate generation failed. Please try again.',
      });
    } finally {
      set({ isLoadingAI: false });
    }
  },

  advanceRound: () => {
    const { currentRoundIndex, rounds, voteProBonus, voteConBonus } = get();
    const next = currentRoundIndex + 1;
    if (next >= rounds.length) {
      const scores = calculateTotalScores(rounds);
      const winner = getWinner(rounds);
      set({
        proScore: scores.pro + voteProBonus,
        conScore: scores.con + voteConBonus,
        winner,
        phase: 'victory',
      });
    } else {
      const playedRounds = rounds.slice(0, next);
      const scores = calculateTotalScores(playedRounds);
      set({
        currentRoundIndex: next,
        proScore: scores.pro + voteProBonus,
        conScore: scores.con + voteConBonus,
      });
    }
  },

  setAnimating: (v: boolean) => set({ isAnimating: v }),

  voteFor: (side: 'PRO' | 'CON', amount: number) => {
    if (side === 'PRO') {
      set(s => ({ voteProBonus: s.voteProBonus + amount, proScore: s.proScore + amount }));
    } else {
      set(s => ({ voteConBonus: s.voteConBonus + amount, conScore: s.conScore + amount }));
    }
  },

  triggerShake: () => {
    set({ shakeScreen: true });
    setTimeout(() => set({ shakeScreen: false }), 500);
  },

  reset: () => set({
    phase: 'input',
    topic: '',
    proHeadline: '',
    conHeadline: '',
    rounds: [],
    currentRoundIndex: 0,
    isAnimating: false,
    proScore: 0,
    conScore: 0,
    voteProBonus: 0,
    voteConBonus: 0,
    winner: null,
    shakeScreen: false,
    isLoadingAI: false,
    aiGenerated: false,
    aiError: null,
  }),
}));
